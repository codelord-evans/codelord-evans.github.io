{"version":3,"file":"mermaid.esm.min.mjs","sources":["../../../node_modules/.pnpm/ts-dedent@2.2.0/node_modules/ts-dedent/esm/index.js","../src/mermaid.ts"],"sourcesContent":["export function dedent(templ) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    var strings = Array.from(typeof templ === 'string' ? [templ] : templ);\n    strings[strings.length - 1] = strings[strings.length - 1].replace(/\\r?\\n([\\t ]*)$/, '');\n    var indentLengths = strings.reduce(function (arr, str) {\n        var matches = str.match(/\\n([\\t ]+|(?!\\s).)/g);\n        if (matches) {\n            return arr.concat(matches.map(function (match) { var _a, _b; return (_b = (_a = match.match(/[\\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0; }));\n        }\n        return arr;\n    }, []);\n    if (indentLengths.length) {\n        var pattern_1 = new RegExp(\"\\n[\\t ]{\" + Math.min.apply(Math, indentLengths) + \"}\", 'g');\n        strings = strings.map(function (str) { return str.replace(pattern_1, '\\n'); });\n    }\n    strings[0] = strings[0].replace(/^\\r?\\n/, '');\n    var string = strings[0];\n    values.forEach(function (value, i) {\n        var endentations = string.match(/(?:^|\\n)( *)$/);\n        var endentation = endentations ? endentations[1] : '';\n        var indentedValue = value;\n        if (typeof value === 'string' && value.includes('\\n')) {\n            indentedValue = String(value)\n                .split('\\n')\n                .map(function (str, i) {\n                return i === 0 ? str : \"\" + endentation + str;\n            })\n                .join('\\n');\n        }\n        string += indentedValue + strings[i + 1];\n    });\n    return string;\n}\nexport default dedent;\n//# sourceMappingURL=index.js.map","/**\n * Web page integration module for the mermaid framework. It uses the mermaidAPI for mermaid\n * functionality and to render the diagrams to svg code!\n */\nimport dedent from 'ts-dedent';\nimport { MermaidConfig } from './config.type';\nimport { log } from './logger';\nimport utils from './utils';\nimport { mermaidAPI, ParseOptions, RenderResult } from './mermaidAPI';\nimport { registerLazyLoadedDiagrams, loadRegisteredDiagrams } from './diagram-api/detectType';\nimport type { ParseErrorFunction } from './Diagram';\nimport { isDetailedError } from './utils';\nimport type { DetailedError } from './utils';\nimport { ExternalDiagramDefinition } from './diagram-api/types';\nimport { UnknownDiagramError } from './errors';\n\nexport type {\n  MermaidConfig,\n  DetailedError,\n  ExternalDiagramDefinition,\n  ParseErrorFunction,\n  RenderResult,\n  ParseOptions,\n  UnknownDiagramError,\n};\n\nexport interface RunOptions {\n  /**\n   * The query selector to use when finding elements to render. Default: `\".mermaid\"`.\n   */\n  querySelector?: string;\n  /**\n   * The nodes to render. If this is set, `querySelector` will be ignored.\n   */\n  nodes?: ArrayLike<HTMLElement>;\n  /**\n   * A callback to call after each diagram is rendered.\n   */\n  postRenderCallback?: (id: string) => unknown;\n  /**\n   * If `true`, errors will be logged to the console, but not thrown. Default: `false`\n   */\n  suppressErrors?: boolean;\n}\n\nconst handleError = (error: unknown, errors: DetailedError[], parseError?: ParseErrorFunction) => {\n  log.warn(error);\n  if (isDetailedError(error)) {\n    // handle case where error string and hash were\n    // wrapped in object like`const error = { str, hash };`\n    if (parseError) {\n      parseError(error.str, error.hash);\n    }\n    errors.push({ ...error, message: error.str, error });\n  } else {\n    // assume it is just error string and pass it on\n    if (parseError) {\n      parseError(error);\n    }\n    if (error instanceof Error) {\n      errors.push({\n        str: error.message,\n        message: error.message,\n        hash: error.name,\n        error,\n      });\n    }\n  }\n};\n\n/**\n * ## run\n *\n * Function that goes through the document to find the chart definitions in there and render them.\n *\n * The function tags the processed attributes with the attribute data-processed and ignores found\n * elements with the attribute already set. This way the init function can be triggered several\n * times.\n *\n * ```mermaid\n * graph LR;\n *  a(Find elements)-->b{Processed}\n *  b-->|Yes|c(Leave element)\n *  b-->|No |d(Transform)\n * ```\n *\n * Renders the mermaid diagrams\n *\n * @param options - Optional runtime configs\n */\nconst run = async function (\n  options: RunOptions = {\n    querySelector: '.mermaid',\n  }\n) {\n  try {\n    await runThrowsErrors(options);\n  } catch (e) {\n    if (isDetailedError(e)) {\n      log.error(e.str);\n    }\n    if (mermaid.parseError) {\n      mermaid.parseError(e as string);\n    }\n    if (!options.suppressErrors) {\n      log.error('Use the suppressErrors option to suppress these errors');\n      throw e;\n    }\n  }\n};\n\nconst runThrowsErrors = async function (\n  { postRenderCallback, querySelector, nodes }: Omit<RunOptions, 'suppressErrors'> = {\n    querySelector: '.mermaid',\n  }\n) {\n  const conf = mermaidAPI.getConfig();\n\n  log.debug(`${!postRenderCallback ? 'No ' : ''}Callback function found`);\n\n  let nodesToProcess: ArrayLike<HTMLElement>;\n  if (nodes) {\n    nodesToProcess = nodes;\n  } else if (querySelector) {\n    nodesToProcess = document.querySelectorAll(querySelector);\n  } else {\n    throw new Error('Nodes and querySelector are both undefined');\n  }\n\n  log.debug(`Found ${nodesToProcess.length} diagrams`);\n  if (conf?.startOnLoad !== undefined) {\n    log.debug('Start On Load: ' + conf?.startOnLoad);\n    mermaidAPI.updateSiteConfig({ startOnLoad: conf?.startOnLoad });\n  }\n\n  // generate the id of the diagram\n  const idGenerator = new utils.initIdGenerator(conf.deterministicIds, conf.deterministicIDSeed);\n\n  let txt: string;\n  const errors: DetailedError[] = [];\n\n  // element is the current div with mermaid class\n  // eslint-disable-next-line unicorn/prefer-spread\n  for (const element of Array.from(nodesToProcess)) {\n    log.info('Rendering diagram: ' + element.id);\n    /*! Check if previously processed */\n    if (element.getAttribute('data-processed')) {\n      continue;\n    }\n    element.setAttribute('data-processed', 'true');\n\n    const id = `mermaid-${idGenerator.next()}`;\n\n    // Fetch the graph definition including tags\n    txt = element.innerHTML;\n\n    // transforms the html to pure text\n    txt = dedent(utils.entityDecode(txt)) // removes indentation, required for YAML parsing\n      .trim()\n      .replace(/<br\\s*\\/?>/gi, '<br/>');\n\n    const init = utils.detectInit(txt);\n    if (init) {\n      log.debug('Detected early reinit: ', init);\n    }\n    try {\n      const { svg, bindFunctions } = await render(id, txt, element);\n      element.innerHTML = svg;\n      if (postRenderCallback) {\n        await postRenderCallback(id);\n      }\n      if (bindFunctions) {\n        bindFunctions(element);\n      }\n    } catch (error) {\n      handleError(error, errors, mermaid.parseError);\n    }\n  }\n  if (errors.length > 0) {\n    // TODO: We should be throwing an error object.\n    throw errors[0];\n  }\n};\n\n/**\n * Used to set configurations for mermaid.\n * This function should be called before the run function.\n * @param config - Configuration object for mermaid.\n */\n\nconst initialize = function (config: MermaidConfig) {\n  mermaidAPI.initialize(config);\n};\n\n/**\n * ## init\n *\n * @deprecated Use {@link initialize} and {@link run} instead.\n *\n * Renders the mermaid diagrams\n *\n * @param config - **Deprecated**, please set configuration in {@link initialize}.\n * @param nodes - **Default**: `.mermaid`. One of the following:\n * - A DOM Node\n * - An array of DOM nodes (as would come from a jQuery selector)\n * - A W3C selector, a la `.mermaid`\n * @param callback - Called once for each rendered diagram's id.\n */\nconst init = async function (\n  config?: MermaidConfig,\n  nodes?: string | HTMLElement | NodeListOf<HTMLElement>,\n  callback?: (id: string) => unknown\n) {\n  log.warn('mermaid.init is deprecated. Please use run instead.');\n  if (config) {\n    initialize(config);\n  }\n  const runOptions: RunOptions = { postRenderCallback: callback, querySelector: '.mermaid' };\n  if (typeof nodes === 'string') {\n    runOptions.querySelector = nodes;\n  } else if (nodes) {\n    if (nodes instanceof HTMLElement) {\n      runOptions.nodes = [nodes];\n    } else {\n      runOptions.nodes = nodes;\n    }\n  }\n  await run(runOptions);\n};\n\n/**\n * Used to register external diagram types.\n * @param diagrams - Array of {@link ExternalDiagramDefinition}.\n * @param opts - If opts.lazyLoad is false, the diagrams will be loaded immediately.\n */\nconst registerExternalDiagrams = async (\n  diagrams: ExternalDiagramDefinition[],\n  {\n    lazyLoad = true,\n  }: {\n    lazyLoad?: boolean;\n  } = {}\n) => {\n  registerLazyLoadedDiagrams(...diagrams);\n  if (lazyLoad === false) {\n    await loadRegisteredDiagrams();\n  }\n};\n\n/**\n * ##contentLoaded Callback function that is called when page is loaded. This functions fetches\n * configuration for mermaid rendering and calls init for rendering the mermaid diagrams on the\n * page.\n */\nconst contentLoaded = function () {\n  if (mermaid.startOnLoad) {\n    const { startOnLoad } = mermaidAPI.getConfig();\n    if (startOnLoad) {\n      mermaid.run().catch((err) => log.error('Mermaid failed to initialize', err));\n    }\n  }\n};\n\nif (typeof document !== 'undefined') {\n  /*!\n   * Wait for document loaded before starting the execution\n   */\n  window.addEventListener('load', contentLoaded, false);\n}\n\n/**\n * ## setParseErrorHandler  Alternative to directly setting parseError using:\n *\n * ```js\n * mermaid.parseError = function(err,hash){=\n *   forExampleDisplayErrorInGui(err);  // do something with the error\n * };\n * ```\n *\n * This is provided for environments where the mermaid object can't directly have a new member added\n * to it (eg. dart interop wrapper). (Initially there is no parseError member of mermaid).\n *\n * @param parseErrorHandler - New parseError() callback.\n */\nconst setParseErrorHandler = function (parseErrorHandler: (err: any, hash: any) => void) {\n  mermaid.parseError = parseErrorHandler;\n};\n\nconst executionQueue: (() => Promise<unknown>)[] = [];\nlet executionQueueRunning = false;\nconst executeQueue = async () => {\n  if (executionQueueRunning) {\n    return;\n  }\n  executionQueueRunning = true;\n  while (executionQueue.length > 0) {\n    const f = executionQueue.shift();\n    if (f) {\n      try {\n        await f();\n      } catch (e) {\n        log.error('Error executing queue', e);\n      }\n    }\n  }\n  executionQueueRunning = false;\n};\n\n/**\n * Parse the text and validate the syntax.\n * @param text - The mermaid diagram definition.\n * @param parseOptions - Options for parsing.\n * @returns true if the diagram is valid, false otherwise if parseOptions.suppressErrors is true.\n * @throws Error if the diagram is invalid and parseOptions.suppressErrors is false.\n */\nconst parse = async (text: string, parseOptions?: ParseOptions): Promise<boolean | void> => {\n  return new Promise((resolve, reject) => {\n    // This promise will resolve when the render call is done.\n    // It will be queued first and will be executed when it is first in line\n    const performCall = () =>\n      new Promise((res, rej) => {\n        mermaidAPI.parse(text, parseOptions).then(\n          (r) => {\n            // This resolves for the promise for the queue handling\n            res(r);\n            // This fulfills the promise sent to the value back to the original caller\n            resolve(r);\n          },\n          (e) => {\n            log.error('Error parsing', e);\n            mermaid.parseError?.(e);\n            rej(e);\n            reject(e);\n          }\n        );\n      });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\n\n/**\n * Function that renders an svg with a graph from a chart definition. Usage example below.\n *\n * ```javascript\n *  element = document.querySelector('#graphDiv');\n *  const graphDefinition = 'graph TB\\na-->b';\n *  const { svg, bindFunctions } = await mermaid.render('graphDiv', graphDefinition);\n *  element.innerHTML = svg;\n *  bindFunctions?.(element);\n * ```\n *\n * @remarks\n * Multiple calls to this function will be enqueued to run serially.\n *\n * @param id - The id for the SVG element (the element to be rendered)\n * @param text - The text for the graph definition\n * @param container - HTML element where the svg will be inserted. (Is usually element with the .mermaid class)\n *   If no svgContainingElement is provided then the SVG element will be appended to the body.\n *    Selector to element in which a div with the graph temporarily will be\n *   inserted. If one is provided a hidden div will be inserted in the body of the page instead. The\n *   element will be removed when rendering is completed.\n * @returns Returns the SVG Definition and BindFunctions.\n */\nconst render = (id: string, text: string, container?: Element): Promise<RenderResult> => {\n  return new Promise((resolve, reject) => {\n    // This promise will resolve when the mermaidAPI.render call is done.\n    // It will be queued first and will be executed when it is first in line\n    const performCall = () =>\n      new Promise((res, rej) => {\n        mermaidAPI.render(id, text, container).then(\n          (r) => {\n            // This resolves for the promise for the queue handling\n            res(r);\n            // This fulfills the promise sent to the value back to the original caller\n            resolve(r);\n          },\n          (e) => {\n            log.error('Error parsing', e);\n            mermaid.parseError?.(e);\n            rej(e);\n            reject(e);\n          }\n        );\n      });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\n\nconst mermaid: {\n  startOnLoad: boolean;\n  parseError?: ParseErrorFunction;\n  mermaidAPI: typeof mermaidAPI;\n  parse: typeof parse;\n  render: typeof render;\n  init: typeof init;\n  run: typeof run;\n  registerExternalDiagrams: typeof registerExternalDiagrams;\n  initialize: typeof initialize;\n  contentLoaded: typeof contentLoaded;\n  setParseErrorHandler: typeof setParseErrorHandler;\n} = {\n  startOnLoad: true,\n  mermaidAPI,\n  parse,\n  render,\n  init,\n  run,\n  registerExternalDiagrams,\n  initialize,\n  parseError: undefined,\n  contentLoaded,\n  setParseErrorHandler,\n};\n\nexport default mermaid;\n"],"names":["dedent","templ","values","_i","strings","indentLengths","arr","str","matches","match","_a","_b","pattern_1","string","value","endentations","endentation","indentedValue","i","handleError","error","errors","parseError","log","isDetailedError","run","options","runThrowsErrors","e","mermaid","postRenderCallback","querySelector","nodes","conf","mermaidAPI","nodesToProcess","idGenerator","utils","txt","element","id","init","svg","bindFunctions","render","initialize","config","callback","runOptions","registerExternalDiagrams","diagrams","lazyLoad","registerLazyLoadedDiagrams","loadRegisteredDiagrams","contentLoaded","startOnLoad","err","setParseErrorHandler","parseErrorHandler","executionQueue","executionQueueRunning","executeQueue","f","parse","text","parseOptions","resolve","reject","performCall","res","rej","r","container"],"mappings":"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"}