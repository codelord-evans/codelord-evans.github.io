{"version":3,"file":"index-e6caf2ad.js","sources":["../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/clone.js","../../../node_modules/.pnpm/dagre-d3-es@7.0.9/node_modules/dagre-d3-es/src/graphlib/json.js","../src/dagre-wrapper/mermaid-graphlib.js","../src/dagre-wrapper/clusters.js","../src/dagre-wrapper/index.js"],"sourcesContent":["import baseClone from './_baseClone.js';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nexport default clone;\n","import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\n\nexport { write, read };\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound(),\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g),\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n","/** Decorates with functions required by mermaids dagre-wrapper. */\nimport { log } from '../logger';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\n\nexport let clusterDb = {};\nlet descendants = {};\nlet parents = {};\n\nexport const clear = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\n\nconst isDescendant = (id, ancenstorId) => {\n  // if (id === ancenstorId) return true;\n\n  log.trace('In isDecendant', ancenstorId, ' ', id, ' = ', descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst edgeInCluster = (edge, clusterId) => {\n  log.info('Decendants of ', clusterId, ' is ', descendants[clusterId]);\n  log.info('Edge is ', edge);\n  // Edges to/from the cluster is not in the cluster, they are in the parent\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n\n  if (!descendants[clusterId]) {\n    log.debug('Tilt, ', clusterId, ',not in decendants');\n    return false;\n  }\n  return (\n    descendants[clusterId].includes(edge.v) ||\n    isDescendant(edge.v, clusterId) ||\n    isDescendant(edge.w, clusterId) ||\n    descendants[clusterId].includes(edge.w)\n  );\n};\n\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\n    'Copying children of ',\n    clusterId,\n    'root',\n    rootId,\n    'data',\n    graph.node(clusterId),\n    rootId\n  );\n  const nodes = graph.children(clusterId) || [];\n\n  // Include cluster node if it is not the root\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n\n  log.warn('Copying (nodes) clusterId', clusterId, 'nodes', nodes);\n\n  nodes.forEach((node) => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info('cp ', node, ' to ', rootId, ' with parent ', clusterId); //,node, data, ' parent is ', clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn('Setting parent', node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug('Setting parent', node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info('In copy ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);\n        log.debug(\n          'Not Setting parent for node=',\n          node,\n          'cluster!==rootId',\n          clusterId !== rootId,\n          'node!==clusterId',\n          node !== clusterId\n        );\n      }\n      const edges = graph.edges(node);\n      log.debug('Copying Edges', edges);\n      edges.forEach((edge) => {\n        log.info('Edge', edge);\n        const data = graph.edge(edge.v, edge.w, edge.name);\n        log.info('Edge data', data, rootId);\n        try {\n          // Do not copy edges in and out of the root cluster, they belong to the parent graph\n          if (edgeInCluster(edge, rootId)) {\n            log.info('Copying as ', edge.v, edge.w, data, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data, edge.name);\n            log.info('newGraph edges ', newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\n              'Skipping copy of edge ',\n              edge.v,\n              '-->',\n              edge.w,\n              ' rootId: ',\n              rootId,\n              ' clusterId:',\n              clusterId\n            );\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug('Removing node', node);\n    graph.removeNode(node);\n  });\n};\nexport const extractDescendants = (id, graph) => {\n  // log.debug('Extracting ', id);\n  const children = graph.children(id);\n  let res = [...children];\n\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n\n  return res;\n};\n\n/**\n * Validates the graph, checking that all parent child relation points to existing nodes and that\n * edges between nodes also ia correct. When not correct the function logs the discrepancies.\n *\n * @param graph\n */\nexport const validate = (graph) => {\n  const edges = graph.edges();\n  log.trace('Edges: ', edges);\n  for (const edge of edges) {\n    if (graph.children(edge.v).length > 0) {\n      log.trace('The node ', edge.v, ' is part of and edge even though it has children');\n      return false;\n    }\n    if (graph.children(edge.w).length > 0) {\n      log.trace('The node ', edge.w, ' is part of and edge even though it has children');\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Finds a child that is not a cluster. When faking an edge between a node and a cluster.\n *\n * @param id\n * @param {any} graph\n */\nexport const findNonClusterChild = (id, graph) => {\n  // const node = graph.node(id);\n  log.trace('Searching', id);\n  // const children = graph.children(id).reverse();\n  const children = graph.children(id); //.reverse();\n  log.trace('Searching children of id ', id, children);\n  if (children.length < 1) {\n    log.trace('This is a valid node', id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace('Found replacement for', id, ' => ', _id);\n      return _id;\n    }\n  }\n};\n\nconst getAnchorId = (id) => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  // If the cluster has no external connections\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n\n  // Return the replacement node\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\n\nexport const adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug('Opting out, no graph ');\n    return;\n  } else {\n    log.debug('Opting in, graph ');\n  }\n  // Go through the nodes and for each cluster found, save a replacement node, this can be used when\n  // faking a link to a cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\n        'Cluster identified',\n        id,\n        ' Replacement id in edges: ',\n        findNonClusterChild(id, graph)\n      );\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };\n    }\n  });\n\n  // Check incoming and outgoing edges for each cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug('Cluster identified', id, descendants);\n      edges.forEach((edge) => {\n        // log.debug('Edge, decendants: ', edge, decendants[id]);\n\n        // Check if any edge leaves the cluster (not the actual cluster, that's a link from the box)\n        if (edge.v !== id && edge.w !== id) {\n          // Any edge where either the one of the nodes is descending to the cluster but not the other\n          // if (decendants[id].indexOf(edge.v) < 0 && decendants[id].indexOf(edge.w) < 0) {\n\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n\n          // d1 xor d2 - if either d1 is true and d2 is false or the other way around\n          if (d1 ^ d2) {\n            log.warn('Edge: ', edge, ' leaves cluster ', id);\n            log.warn('Decendants of XXX ', id, ': ', descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug('Not a cluster ', id, descendants);\n    }\n  });\n\n  // For clusters with incoming and/or outgoing edges translate those edges to a real node\n  // in the cluster in order to fake the edge\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));\n\n    let v = e.v;\n    let w = e.w;\n    // Check if link is either from or to a cluster\n    log.warn(\n      'Fix XXX',\n      clusterDb,\n      'ids:',\n      e.v,\n      e.w,\n      'Translating: ',\n      clusterDb[e.v],\n      ' --- ',\n      clusterDb[e.w]\n    );\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn('Fixing and trixing link to self - removing XXX', e.v, e.w, e.name);\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + '---' + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: '',\n        labelText: edge.label,\n        padding: 0,\n        shape: 'labelRect',\n        style: '',\n      });\n      const edge1 = JSON.parse(JSON.stringify(edge));\n      const edge2 = JSON.parse(JSON.stringify(edge));\n      edge1.label = '';\n      edge1.arrowTypeEnd = 'none';\n      edge2.label = '';\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n\n      graph.setEdge(v, specialId, edge1, e.name + '-cyclic-special');\n      graph.setEdge(specialId, w, edge2, e.name + '-cyclic-special');\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn('Fix Replacing with XXX', v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn('Adjusted Graph', graphlibJson.write(graph));\n  extractor(graph, 0);\n\n  log.trace(clusterDb);\n\n  // Remove references to extracted cluster\n  // graph.edges().forEach(edge => {\n  //   if (isDecendant(edge.v, clusterId) || isDecendant(edge.w, clusterId)) {\n  //     graph.removeEdge(edge);\n  //   }\n  // });\n};\n\nexport const extractor = (graph, depth) => {\n  log.warn('extractor - ', depth, graphlibJson.write(graph), graph.children('D'));\n  if (depth > 10) {\n    log.error('Bailing out');\n    return;\n  }\n  // For clusters without incoming and/or outgoing edges, create a new cluster-node\n  // containing the nodes and edges in the custer in a new graph\n  // for (let i = 0;)\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n\n  if (!hasChildren) {\n    log.debug('Done, no node has children', graph.nodes());\n    return;\n  }\n  // const clusters = Object.keys(clusterDb);\n  // clusters.forEach(clusterId => {\n  log.debug('Nodes = ', nodes, depth);\n  for (const node of nodes) {\n    log.debug(\n      'Extracting node',\n      node,\n      clusterDb,\n      clusterDb[node] && !clusterDb[node].externalConnections,\n      !graph.parent(node),\n      graph.node(node),\n      graph.children('D'),\n      ' Depth ',\n      depth\n    );\n    // Note that the node might have been removed after the Object.keys call so better check\n    // that it still is in the game\n    if (!clusterDb[node]) {\n      // Skip if the node is not a cluster\n      log.debug('Not a cluster', node, depth);\n      // break;\n    } else if (\n      !clusterDb[node].externalConnections &&\n      // !graph.parent(node) &&\n      graph.children(node) &&\n      graph.children(node).length > 0\n    ) {\n      log.warn(\n        'Cluster without external connections, without a parent and with children',\n        node,\n        depth\n      );\n\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === 'TB' ? 'LR' : 'TB';\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn('Fixing dir', clusterDb[node].clusterData.dir, dir);\n      }\n\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true,\n      })\n        .setGraph({\n          rankdir: dir, // Todo: set proper spacing\n          nodesep: 50,\n          ranksep: 50,\n          marginx: 8,\n          marginy: 8,\n        })\n        .setDefaultEdgeLabel(function () {\n          return {};\n        });\n\n      log.warn('Old graph before copy', graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph,\n      });\n      log.warn('New graph after copy node: (', node, ')', graphlibJson.write(clusterGraph));\n      log.debug('Old graph after copy', graphlibJson.write(graph));\n    } else {\n      log.warn(\n        'Cluster ** ',\n        node,\n        ' **not meeting the criteria !externalConnections:',\n        !clusterDb[node].externalConnections,\n        ' no parent: ',\n        !graph.parent(node),\n        ' children ',\n        graph.children(node) && graph.children(node).length > 0,\n        graph.children('D'),\n        depth\n      );\n      log.debug(clusterDb);\n    }\n  }\n\n  nodes = graph.nodes();\n  log.warn('New list of nodes', nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(' Now next level', node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\n\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach((node) => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n\n  return result;\n};\n\nexport const sortNodesByHierarchy = (graph) => sorter(graph, graph.children());\n","import intersectRect from './intersect/intersect-rect';\nimport { log } from '../logger';\nimport createLabel from './createLabel';\nimport { select } from 'd3';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\n\nconst rect = (parent, node) => {\n  log.trace('Creating subgraph rect for ', node.id, node);\n\n  // Add outer g element\n  const shapeSvg = parent\n    .insert('g')\n    .attr('class', 'cluster' + (node.class ? ' ' + node.class : ''))\n    .attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  log.trace('Data ', node, JSON.stringify(node));\n  // center the rect around its coordinate\n  rect\n    .attr('style', node.style)\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - width / 2)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width)\n    .attr('height', node.height + padding);\n\n  // Center the label\n  label.attr(\n    'transform',\n    // This puts the labal on top of the box instead of inside it\n    // 'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2 - bbox.height) + ')'\n    'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2) + ')'\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\n/**\n * Non visible cluster where the note is group with its\n *\n * @param {any} parent\n * @param {any} node\n * @returns {any} ShapeSvg\n */\nconst noteGroup = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', 'note-cluster').attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding)\n    .attr('fill', 'none');\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n  const innerRect = shapeSvg.append('rect');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'outer')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding);\n  innerRect\n    .attr('class', 'inner')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding + bbox.height - 1)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding - bbox.height - 3);\n\n  // Center the label\n  label.attr(\n    'transform',\n    'translate(' +\n      (node.x - bbox.width / 2) +\n      ', ' +\n      (node.y -\n        node.height / 2 -\n        node.padding / 3 +\n        (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) +\n      ')'\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst divider = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'divider')\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding);\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst shapes = { rect, roundedWithTitle, noteGroup, divider };\n\nlet clusterElems = {};\n\nexport const insertCluster = (elem, node) => {\n  log.trace('Inserting cluster');\n  const shape = node.shape || 'rect';\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nexport const getClusterTitleWidth = (elem, node) => {\n  const label = createLabel(node.labelText, node.labelStyle, undefined, true);\n  elem.node().appendChild(label);\n  const width = label.getBBox().width;\n  elem.node().removeChild(label);\n  return width;\n};\n\nexport const clear = () => {\n  clusterElems = {};\n};\n\nexport const positionCluster = (node) => {\n  log.info('Position cluster (' + node.id + ', ' + node.x + ', ' + node.y + ')');\n  const el = clusterElems[node.id];\n\n  el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');\n};\n","import { layout as dagreLayout } from 'dagre-d3-es/src/dagre/index.js';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport insertMarkers from './markers';\nimport { updateNodeBounds } from './shapes/util';\nimport {\n  clear as clearGraphlib,\n  clusterDb,\n  adjustClustersAndEdges,\n  findNonClusterChild,\n  sortNodesByHierarchy,\n} from './mermaid-graphlib';\nimport { insertNode, positionNode, clear as clearNodes, setNodeElem } from './nodes';\nimport { insertCluster, clear as clearClusters } from './clusters';\nimport { insertEdgeLabel, positionEdgeLabel, insertEdge, clear as clearEdges } from './edges';\nimport { log } from '../logger';\n\nconst recursiveRender = (_elem, graph, diagramtype, parentCluster) => {\n  log.info('Graph in recursive render: XXX', graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace('Dir in recursive render - dir:', dir);\n\n  const elem = _elem.insert('g').attr('class', 'root');\n  if (!graph.nodes()) {\n    log.info('No nodes found for', graph);\n  } else {\n    log.info('Recursive render XXX', graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace('Recursive edges', graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert('g').attr('class', 'clusters');\n  const edgePaths = elem.insert('g').attr('class', 'edgePaths');\n  const edgeLabels = elem.insert('g').attr('class', 'edgeLabels');\n  const nodes = elem.insert('g').attr('class', 'nodes');\n\n  // Insert nodes, this will insert them into the dom and each node will get a size. The size is updated\n  // to the abstract node and is later used by dagre for the layout\n  graph.nodes().forEach(function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== undefined) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      // data.clusterPositioning = true;\n      log.info('Setting data for cluster XXX (', v, ') ', data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace('Setting parent', v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info('(Insert) Node XXX' + v + ': ' + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      // const children = graph.children(v);\n      log.info('Cluster identified', v, node.width, graph.node(v));\n      const o = recursiveRender(nodes, node.graph, diagramtype, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info('Node bounds (abc123)', v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n\n      log.warn('Recursive render complete ', newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        // This is a cluster but not to be rendered recursively\n        // Render as before\n        log.info('Cluster - the non recursive path XXX', v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };\n        // insertCluster(clusters, graph.node(v));\n      } else {\n        log.info('Node - the non recursive path', v, node.id, node);\n        insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  });\n\n  // Insert labels, this will insert them into the dom so that the width can be calculated\n  // Also figure out which edges point to/from clusters and adjust them accordingly\n  // Edges from/to clusters really points to the first child in the cluster.\n  // TODO: pick optimal child in the cluster to us as link anchor\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ', e, ' ', JSON.stringify(graph.edge(e)));\n\n    // Check if link is either from or to a cluster\n    log.info('Fix', clusterDb, 'ids:', e.v, e.w, 'Translateing: ', clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n\n  graph.edges().forEach(function (e) {\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n  });\n  log.info('#############################################');\n  log.info('###                Layout                 ###');\n  log.info('#############################################');\n  log.info(graph);\n  dagreLayout(graph);\n  log.info('Graph after layout:', graphlibJson.write(graph));\n  // Move the nodes to the correct place\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info('Position ' + v + ': ' + JSON.stringify(graph.node(v)));\n    log.info(\n      'Position ' + v + ': (' + node.x,\n      ',' + node.y,\n      ') width: ',\n      node.width,\n      ' height: ',\n      node.height\n    );\n    if (node && node.clusterNode) {\n      // clusterDb[node.id].node = node;\n\n      positionNode(node);\n    } else {\n      // Non cluster node\n      if (graph.children(v).length > 0) {\n        // A cluster in the non-recursive way\n        // positionCluster(node);\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n\n  // Move the edge labels to the correct place after layout\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(edge), edge);\n\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph);\n    positionEdgeLabel(edge, paths);\n  });\n\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === 'group') {\n      diff = n.diff;\n    }\n  });\n  return { elem, diff };\n};\n\nexport const render = (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clearNodes();\n  clearEdges();\n  clearClusters();\n  clearGraphlib();\n\n  log.warn('Graph at first:', graphlibJson.write(graph));\n  adjustClustersAndEdges(graph);\n  log.warn('Graph after:', graphlibJson.write(graph));\n  // log.warn('Graph ever  after:', graphlibJson.write(graph.node('A').graph));\n  recursiveRender(elem, graph, diagramtype);\n};\n\n// const shapeDefinitions = {};\n// export const addShape = ({ shapeType: fun }) => {\n//   shapeDefinitions[shapeType] = fun;\n// };\n\n// const arrowDefinitions = {};\n// export const addArrow = ({ arrowType: fun }) => {\n//   arrowDefinitions[arrowType] = fun;\n// };\n"],"names":["CLONE_SYMBOLS_FLAG","clone","value","baseClone","write","g","json","writeNodes","writeEdges","_.isUndefined","_.clone","_.map","v","nodeValue","parent","node","e","edgeValue","edge","clusterDb","descendants","parents","clear","isDescendant","id","ancenstorId","log","edgeInCluster","clusterId","copy","graph","newGraph","rootId","nodes","data","edges","extractDescendants","children","res","child","findNonClusterChild","_id","getAnchorId","adjustClustersAndEdges","depth","d1","d2","w","specialId","edge1","edge2","graphlibJson.write","extractor","hasChildren","dir","clusterGraph","graphlib.Graph","sorter","result","sorted","sortNodesByHierarchy","rect","shapeSvg","label","text","createLabel","bbox","evaluate","getConfig","div","dv","select","padding","halfPadding","width","rectBox","point","intersectRect","noteGroup","roundedWithTitle","innerRect","divider","shapes","clusterElems","insertCluster","elem","shape","recursiveRender","_elem","diagramtype","parentCluster","clusters","edgePaths","edgeLabels","o","newEl","updateNodeBounds","setNodeElem","insertNode","insertEdgeLabel","dagreLayout","diff","positionNode","paths","insertEdge","positionEdgeLabel","n","render","markers","insertMarkers","clearNodes","clearEdges","clearClusters","clearGraphlib"],"mappings":"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"}